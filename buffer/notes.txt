rozmýšlaj nad implementáciou bufferu, potrebujem stopiť tento kód

glGenBuffers(1, &vbo);
glBindBuffer(GL_ARRAY_BUFFER, vbo);
glBufferData(GL_ARRAY_BUFFER, 7*3*sizeof(GLfloat), NULL, GL_STATIC_DRAW);
glBufferSubData(GL_ARRAY_BUFFER, 0, 3*3*sizeof(GLfloat), (GLvoid *)vertices);
glBufferSubData(GL_ARRAY_BUFFER, 3*3*sizeof(GLfloat), 3*4*sizeof(GLfloat), 
	(GLvoid *)colors);


pri niečom taktom, sa počet riadkou nemení

gl::buffer vbo(GL_ARRAY_BUFFER);
vbo.bind();

glBufferData(GL_ARRAY_BUFFER, 7*3*sizeof(GLfloat), NULL, GL_STATIC_DRAW);
glBufferSubData(GL_ARRAY_BUFFER, 0, 3*3*sizeof(GLfloat), (GLvoid *)vertices);
glBufferSubData(GL_ARRAY_BUFFER, 3*3*sizeof(GLfloat), 3*4*sizeof(GLfloat), 
	(GLvoid *)colors);


čo tak toto

gl::buffer vbo(GL_ARRAY_BUFFER, 7*3*sizeof(GLfloat));  // already binded
glBufferSubData(GL_ARRAY_BUFFER, 0, 3*3*sizeof(GLfloat), (GLvoid *)vertices);
glBufferSubData(GL_ARRAY_BUFFER, 3*3*sizeof(GLfloat), 3*4*sizeof(GLfloat), 
	(GLvoid *)colors);


čo implikuje, že konštruktor bufferu je ekvivalentom glBufferData()

gl::buffer vbo(GL_ARRAY_BUFFER);
vbo.bind();
// raw ogl init

gl::buffer vbo(GL_ARRAY_BUFFER, 7*3*sizeof(GLfloat), [GL_STATIC_DRAW]);
// raw ogl init

gl::buffer vbo(GL_ARRAY_BUFFER, 7*3*sizeof(GLfloat), data, [GL_STATIC_DRAW]);
// raw ogl init

class buffer
{
public:
	buffer(GLenum type);
	buffer(GLenum type, GLsizei size, GLenum purpose = GL_STATIC_DRAW);
	buffer(GLenum type, GLsizei size, GLvoid * data, 
		GLenum purpose = GL_STATIC_DRAW);
	void bind();
	void unbind();
};





