{program}

Program definuje niekoľko štruktúr

	* uniform_variable
	* shader_module
	* shader_program


{{uniform_variable}}

Prvá uniform_variable modeluje shader-uniform a používa sa takto [Ukážka:

	uniform_variable u("scale", prog);
	u = 12.43f;

	uniform_variable u;
	...
	u.link("scale", prog);
	u = 12.43f;

--- koniec ukážky]. Trieda uniform_variable implementuje univerzálny operátor=,
k pridaniu podpory pre ďalší typ stčí špecializovať šablónovú funkciu [Ukážka:

	template <typename T>
	void primitive_uniform_upload(GLint location, T const & v);

--- koniec ukážky]. Napr. takto sa dá pridať podpora pre texturu [Ukážka:

	class texture {...};
	
	template <>
	void primitive_uniform_upload<texture>(GLint location, texture const & t)
	{
		texture_unit = t.texture_unit();
		glUniform1i(location, texture_unit);
	}

	foo()
	{
		texture tex;
		...
		prog.use();
		uniform_variable u("tex", prog);
		u = tex;
		render();
		prog.unuse();
	}

--- koniec ukážky]. Alebo implementáciou vlastného typu a operátoru= [Ukážka:

	class texture {...};

	class texture_uniform : public uniform_variable
	{
	public:
		using uniform_variable::uniform_variable;
		
		texture_uniform & operator=(texture const & t)
		{
			texture_unit = t.texture_unit();
			glUniform1i(location(), texture_unit);
			return *this;
		}
	};

	foo()
	{
		texture tex;
		...
		prog.use();
		texture_uniform u("tex", prog);
		u = tex;
		render();
		prog.unuse();
	}

--- koniec ukážky].


{{shader_module}}

Trieda shader_module modeluje shader-object (dokumentácia OpenGL tak označuje
celý, alebo časť 'programu' pre shader (niečo ako objektový súbor v c++)). Modul
môžem vytvoriť takto [Ukážka:

	shader_module m1("simple.vs");  #1
	shader_module m2("simple.vs", GL_VERTEX_SHADER);  #2

--- koniec ukážky]. V prípade #1 sa typ shaderu určí na základe koncovky súboru,
#2 je typ určený parametrom konštruktoru.


{{shader_program}}

Trieda shader_program modeluje OpenGL shader-program, teda linkovateľnú množinu
shader-object-ov (shader_module). Používa sa takto [Ukážka:

	shader_program prog;
	prog << "basic.vs" << "plastic.fs";  // load and compile shader modules
	prog.link();
	prog.use();
	uniform_variable u("color", program);
	u = glm::vec4(1.0, 0.0, 0.0, 1.0);
	render();
	prog.unuse();

--- koniec ukážky]. Asociovať modul s programom je možne volaním funkcie
attach(), alebo operator<<() [Ukážka:

	shader_program prog;
	prog << "basic.vs" << make_ptr<shader_module>("basic.gs");
	prog.attach("basic.fs");
	prog.link();

--- koniec ukážky]. Ak sme pridali všetky moduly je potrebné program zlinkovať,
volaním funkcie link().



{buffers}

{{mesh_buffers}}

Trieda mesh_buffers umožnuje vykresliť množinu vrcholou. Jedná sa o low-level
štruktúru navrhnutú tak aby spolupracovala v s triedami attribute_buffer, a
buffer [Ukážka:

--- koniec ukážky].



{scenegraph}

	* scene_manager
	* scene_node
	

{{scene_node}}

Uzol je ťažným koňom scény, umožnuje do scény pridať ľubovolnú funkcionalitu.

podpora pre tweakbar
assoc_module, get_module


\section Resource

Scénu je možné popísať pomocou lua skriptu (náhrada za xml), až na malé zmeny je
všetko kompatibilné s pôvodnou implementáciou (pozri dokumentáciu).

Jednotlivé elementy (node, module, sequence, program, ...) sú implementované ako
tabuľky. Každá tabuľka t obsahuje prvok t.type v ktorom je typ elementu (napr.
element node -> t.type == 'node').

\code{.lua}
node{
	flags='camera',
	mesh{id='geometry', value='cube.mesh'}
}
\endcode

Dvojice klúč, hodnota (key=value) reprezentujú atributy elementu a type{}
zasa elementy (node, call, foreach, ...).


\subsection Node

Element node je definovaný takto

\code{.lua}
node{
	name='cube_node', 
	flags={'object','castshadow'}
	translate{<n>,<n>,<n>},  // x,y,z
	rotate{<n>,<n>,<n>},     // x,y,z v stupňoch
	bounds{xmin=<n>, xmax=<n>, ymin=<n>, ymax=<n>, zmin=<n>, zmax=<n>},
	uniformNf{id=<s>, name=<s>, <vecN>},
	module{id=<s>, value=<var>},
	mesh{id=<s>, value=<s>},
	field{id=<s>, value=<var>},
	method{id=<s>, value=<var>},
}
\endcode

--- koniec ukážky], kde <n> predstavuje číslo, <s> reťazec, <vec3> vektor
{<n>,<n>,<n>} a <var> globálnu premennú. 

Atribút value sa musí odkazovať buď na globálnu premennú, alebo byť reťazcom.

Ak je value reťazcom (odkazuje sa na súbor), potom do resource-managera ide v
tvare type:value (napr. 'mesh:cube.mesh'), v tomto tvare ho je s RM možné aj
získať.


\subsubsection mesh

Pole mesh musí obsahovať polia id=<s> a value=<s>, kde id je meno pod ktorý,
bude mriežka asociovaná v uzle (\sa scene_node::assoc_mesh()), ukážka

\code{.lua}
node{
	mesh{id='geometry', value='cube.mesh'}
}
\endcode


{{module}}

	module{
		name=<s>, 
		version=<n>,
		source=<s>|(vertex=<s>*, fragment=<s>*),
		options=<s>,
		feedback=<s>,
		uniform_smpler{name=<s>*, texture=<s>*},
		uniform1f{name=<s>*, <vec1>*},
		uniform2f{name=<s>*, <vec2>*},
		uniform3f{name=<s>*, <vec3>*},
		uniform4f{name=<s>*, <vec4>*},
		uniform_matrxi{},
		uniform_subroutine{name, subroutine, stage},
		
		
	}
	
znak * označuje povinné údaje

\section Metódy

set_program, drawmesh, ...

\subsection set_program

Vytvorí task nastavujúci program (\sa program_task_factory)

\code{.lua}
set_program{
	module{name='camera.material'},
	module{name='this.material'},
}
\endcode


\subsubsection module

Identifikuje modul programu.

formát:module{name=<s>}

kde name je tzv. qualified-name meno pozostavajúce s dvoch častí
<target>.<name>. Target predstavuje cielový uzol a name je modul asosiovaný pod
týmto menom (\sa scene_node::assoc_module()).


\subsection drawmesh

Task zobrazujúci mriežku.

formát:drawmesh{name=<s>, count=<n>}


\subsection transforms-task

screen, module, time, loacalToWorld, localToScreen, cameraToWorld, 
screenToScreen, screenToCamera, worldToScreen, worldPos, worldDir


{window} 

Ukážka vytvorenia okna v SDL [Example:

	#include "sdl_window.h"

	class app : public sdl_window
	{
	public:
		typedef sdl_window base;

		app()	: base(parameters().size(800, 600))	
		{
			glClearColor(.5f, .5f, .5f, 1.0f);		
		}

		void display() 
		{
			glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
			base::display();
		}
	};

	int main(int argc, char * argv[])
	{
		app a;
		a.start();
		return 0;
	}

--- end example] a vytvorenia okna v glute (glut je zatial hlavná platforma
vývoja) [Example:

	class app : public glut_window
	{
	public:
		typedef glut_window base;
	// všetko ostatné je rovnaké ako pri SDL ...

--- koniec ukážky].


\subsection subsect_node Node



{utility}

Zapisovanie do pamäte je možné pomocou triedy memory_stream. Trieda definuje
operator<<() pre všetky kopírovatelne typy. [Ukážka:

	struct goo {
		float x, y, z;
	};

	memory_stream & operator<<(memory_stream & s, goo & g) {
		s << g.x << g.y;
		return s;
	}

	memory_stream mout(bufsize);
	int i = 10;
	double d = 11.01;
	long l = 101;
	float f = 14.04;
	goo g{1, 2, 3};
	mout << i << d << l << f << g;

	int * ibuf = mout.buf<int>();
	cout << *ibuf;

	double * dbuf = mout.buf<double>(sizeof(int));
	cout << *dbuf;

	goo * gbuf = mout.buf<goo>(
		sizeof(int) + sizeof(double) + sizeof(long) + sizeof(float));
	cout << g.x << " " << g.y << " " << g.z;

	mout.close();

--- koniec ukážky]. Využiť memory_stream je mažné napr. pri plnení buffer-u pre
openGL vertex-buffer.


\subsection subsect_tokenizer Tokenizer

\headerfile core/utils.hpp

Tokenizer definuje funkciu tokenizer(), ktorej použitie je priamočiaré

\code{.cpp}
#include "core/utils.hpp"
...
string text = "hello,,,jane,,";
for (auto s : tokenizer(text, ","))
	cout << s << "\n";
\endcode

